<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Wing Chun Simon • GitHub Pages</title>
  <style>
    :root{ --btn-size:84px; --btn-radius:14px; }
    html,body{ margin:0; height:100%; background:#0b0b0b; color:#eee; font-family:system-ui,Segoe UI,Roboto,Arial; }
    canvas{ display:block; width:100%; height:100%; }
    #hint{ position:fixed; left:0; right:0; top:0; text-align:center; padding:6px; font-size:13px; opacity:.85; z-index:10 }
    #err { position:fixed; left:0; right:0; top:28px; padding:6px; text-align:center; color:#fff; background:#a22; font-size:12px; display:none; z-index:9999 }
    #ui  { position:fixed; left:0; right:0; bottom:0; padding:12px; display:grid;
           grid-template-columns:repeat(4, var(--btn-size)); gap:12px; justify-content:center; z-index:10;
           background:linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,.55)); }
    #ui button{ width:var(--btn-size); height:var(--btn-size); border:0; border-radius:var(--btn-radius);
                background:#222; color:#eee; font-weight:700; letter-spacing:.2px; font-size:14px;
                box-shadow:0 1px 6px rgba(0,0,0,.35); user-select:none; cursor:pointer; }
    #ui button:active{ transform:scale(.985) }
    @media (max-width:820px){ :root{ --btn-size:68px; } }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "./vendor/three.module.js",
      "three/addons/": "./vendor/"
    }
  }
  </script>
</head>
<body>
  <div id="hint">Cliquez pour activer le son. Perso de dos devant le mannequin. Boutons carrés.</div>
  <div id="err"></div>
  <canvas id="c"></canvas>

  <div id="ui">
    <button data-act="pak"   aria-label="Pak Sao">Pak</button>
    <button data-act="tan"   aria-label="Tan Sao">Tan</button>
    <button data-act="bon"   aria-label="Bon Sao">Bon</button>
    <button data-act="punch" aria-label="Punch">Punch</button>
  </div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/DRACOLoader.js';

/* ===== erreurs ===== */
const showErr = (msg)=>{
  const el = document.getElementById('err');
  el.textContent = msg;
  el.style.display = 'block';
  console.error(msg);
};
addEventListener('error', e => showErr('JS Error: ' + (e.error?.stack || e.message)));
addEventListener('unhandledrejection', e => showErr('Promise Error: ' + (e.reason?.stack || e.reason)));

/* ===== renderer / scène / caméra ===== */
const canvas   = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0e0e12);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, .1, 100);
camera.position.set(0, 1.6, 6);
camera.lookAt(0, 1.2, 0);

/* ===== lumières ===== */
scene.add(new THREE.AmbientLight(0xffffff, .28));
const dl = new THREE.DirectionalLight(0xffffff, 2.0);
dl.position.set(1.2, 2.2, 1.5);
dl.castShadow = true;
scene.add(dl);

/* ===== sol ===== */
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(40,40),
  new THREE.MeshStandardMaterial({color:0x1e1e20, roughness:1})
);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

/* ===== mannequin ===== */
const wood = new THREE.MeshStandardMaterial({color:0x6a4a2f, roughness:.6});
const dummy = new THREE.Group();
const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.25,0.25,2.4,20), wood); trunk.position.y = 1.2;
function arm(len, r){ return new THREE.Mesh(new THREE.CylinderGeometry(r,r,len,16), wood); }
const armL = arm(0.6,0.05); armL.rotation.z =  Math.PI/2; armL.position.set(-0.35,1.55,0);
const armR = arm(0.6,0.05); armR.rotation.z =  Math.PI/2; armR.position.set( 0.35,1.55,0);
const armC = arm(0.5,0.05); armC.rotation.z =  Math.PI/2; armC.position.set( 0.00,1.15,0);
const leg  = arm(0.8,0.06); leg.rotation.x =  Math.PI/2; leg.position.set(0,0.55,0.18);
dummy.add(trunk, armL, armR, armC, leg);
scene.add(dummy);

/* ===== conteneur personnage ===== */
const person = new THREE.Group();
person.position.set(0,0,1.6);
scene.add(person);
(function(){ const t = new THREE.Vector3(0,1.2,0); person.lookAt(t); person.rotateY(Math.PI); })();

/* ===== bones sélectionnés ===== */
const charBones = { R:{upper:null,fore:null,hand:null}, L:{upper:null,fore:null,hand:null} };

/* ===== utilitaires rig ===== */
function getArmatureRoots(root){
  const roots = new Set();
  root.traverse(o=>{ if (o.isBone && (!o.parent || !o.parent.isBone)) roots.add(o); });
  return [...roots];
}
function meshBelongsToArmature(skinned, rootBone){
  if (!skinned.isSkinnedMesh || !skinned.skeleton) return false;
  return skinned.skeleton.bones.some(b=>{ let p=b; while(p){ if (p===rootBone) return true; p=p.parent; } return false; });
}
/* Regroupe les SkinnedMesh par armature root + calcule centre monde */
function clusterByArmature(sceneRoot){
  const roots = getArmatureRoots(sceneRoot);
  const clusters = roots.map(r=>({ root:r, meshes:[], center:new THREE.Vector3() }));
  const tmpBox = new THREE.Box3(), tmpC = new THREE.Vector3();
  sceneRoot.traverse(o=>{
    if (o.isSkinnedMesh){
      const root = roots.find(rt=>meshBelongsToArmature(o, rt));
      if (root){
        const cl = clusters.find(c=>c.root===root);
        cl.meshes.push(o);
      }
    }
  });
  clusters.forEach(c=>{
    if (c.meshes.length){
      tmpBox.makeEmpty();
      c.meshes.forEach(m=> tmpBox.expandByObject(m));
      tmpBox.getCenter(c.center);
    }
  });
  return clusters.filter(c=>c.meshes.length);
}

/* Garde le rig le plus proche du mannequin (0,1.2,0) et masque les autres */
function keepClosestArmature(sceneRoot){
  const clusters = clusterByArmature(sceneRoot);
  if (clusters.length <= 1) return; // déjà unique
  const target = new THREE.Vector3(0,1.2,0);
  let best = clusters[0], bestD = best.center.distanceTo(target);
  for (let i=1;i<clusters.length;i++){
    const d = clusters[i].center.distanceTo(target);
    if (d < bestD){ best = clusters[i]; bestD = d; }
  }
  clusters.forEach(c=>{
    if (c !== best){
      c.meshes.forEach(m=> m.visible = false);
      c.root.traverse(b=> b.visible = false);
    }
  });
}

/* Cherche les os automatiquement par regex */
function autoPickBones(model){
  const bones = [];
  model.traverse(o=>{ if (o.isBone) bones.push(o); });
  const pick = (side, ...cands)=>{
    const sideRx = side==='R' ? /(right|\br\b)/i : /(left|\bl\b)/i;
    for (const rx of cands){
      const b = bones.find(n => sideRx.test(n.name) && rx.test(n.name));
      if (b) return b;
    }
    return null;
  };
  charBones.R.upper = pick('R', /(upperarm|^arm(?!ature)|shoulder)/i);
  charBones.R.fore  = pick('R', /(forearm|lowerarm|elbow)/i) || charBones.R.upper;
  charBones.R.hand  = pick('R', /(hand|wrist)/i);

  charBones.L.upper = pick('L', /(upperarm|^arm(?!ature)|shoulder)/i);
  charBones.L.fore  = pick('L', /(forearm|lowerarm|elbow)/i) || charBones.L.upper;
  charBones.L.hand  = pick('L', /(hand|wrist)/i);
}

/* ===== charge GLB et remplace tout ===== */
async function loadGLBCharacter(){
  try{
    const loader = new GLTFLoader();
    const draco  = new DRACOLoader();
    draco.setDecoderPath('./vendor/draco/');
    loader.setDRACOLoader(draco);

    const url = './assets/models/MaleCharBaseMesh.glb';
    const gltf = await loader.loadAsync(url);
    const model = gltf.scene || gltf.scenes?.[0];
    if (!model) throw new Error('GLB sans scène');

    // isole: garde le rig le plus proche du mannequin
    keepClosestArmature(model);

    // normalise taille/position/orientation
    const box  = new THREE.Box3().setFromObject(model);
    const size = new THREE.Vector3(); box.getSize(size);
    model.scale.setScalar(size.y>0 ? 1.75/size.y : 1);
    const box2 = new THREE.Box3().setFromObject(model);
    const center2 = new THREE.Vector3(); box2.getCenter(center2);
    model.position.set(-center2.x, -box2.min.y, -center2.z);
    model.rotation.y = Math.PI;
    model.traverse(o=>{ if (o.isMesh){ o.castShadow=o.receiveShadow=true; } });

    person.clear();
    person.add(model);

    autoPickBones(model);
    console.log('Bones choisis:', {
      rArm: charBones.R.upper?.name, rFore: charBones.R.fore?.name, rHand: charBones.R.hand?.name,
      lArm: charBones.L.upper?.name, lFore: charBones.L.fore?.name, lHand: charBones.L.hand?.name
    });
  }catch(e){
    showErr('Erreur chargement perso GLB: ' + e.message);
  }
}
loadGLBCharacter();

/* ===== AUDIO fiable (HTMLAudio) ===== */
const sounds = {
  pak:   new Audio('./assets/sounds/pak.wav'),
  tan:   new Audio('./assets/sounds/tan.wav'),
  bon:   new Audio('./assets/sounds/bon.wav'),
  punch: new Audio('./assets/sounds/punch.wav')
};
Object.values(sounds).forEach(a=>{ a.preload='auto'; a.crossOrigin = 'anonymous'; });

function playSound(key){
  const a = sounds[key];
  if (!a) return;
  try { a.pause(); a.currentTime = 0; a.play(); }
  catch(err){ console.warn('Audio play bloqué:', err); }
}
// déverrouille au premier clic tactile/souris
addEventListener('pointerdown', ()=>{
  Object.values(sounds).forEach(a=>{ try{ a.play().then(()=>a.pause()).catch(()=>{}); }catch{} });
}, { once:true });

/* ===== UI ===== */
document.querySelectorAll('#ui button').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const a = btn.dataset.act;
    if (a==='pak')   pak();
    if (a==='tan')   tan();
    if (a==='bon')   bon();
    if (a==='punch') punch();
  });
});

/* ===== effets / tweens ===== */
function dummyHit(side=0){
  const startZ = dummy.rotation.z; const tilt = 0.05*(side||1);
  const t0 = performance.now();
  function f(now){
    const k = Math.min(1,(now-t0)/70);
    dummy.rotation.z = startZ + tilt*k;
    if (k<1) requestAnimationFrame(f);
    else {
      const t1 = performance.now();
      function b(n2){
        const k2 = Math.min(1,(n2-t1)/110);
        dummy.rotation.z = startZ + tilt*(1-k2);
        if (k2<1) requestAnimationFrame(b);
      }
      requestAnimationFrame(b);
    }
  }
  requestAnimationFrame(f);
}

const rotRef = (obj, axis) => ({ set(v){ obj[axis]=v; }, get(){ return obj[axis]||0; } });
function tweenRot(ref, from, to, dur, onEnd){
  const t0 = performance.now();
  function step(now){
    const k = Math.min(1,(now-t0)/dur);
    ref.set(from + (to-from)*k);
    if (k<1) requestAnimationFrame(step); else onEnd && onEnd();
  }
  requestAnimationFrame(step);
}

/* ===== techniques ===== */
let busy = false;
function pak(){
  if (busy) return; busy = true;
  const fore = charBones.R.fore || charBones.R.upper;
  if (fore){
    const ref = rotRef(fore.rotation,'y'); const s = ref.get();
    tweenRot(ref, s, s-0.35, 100, ()=>{ dummyHit(+1); playSound('pak'); tweenRot(ref, s-0.35, s, 120, ()=>busy=false); });
  } else { dummyHit(+1); playSound('pak'); busy=false; }
}
function tan(){
  if (busy) return; busy = true;
  const fore = charBones.L.fore || charBones.L.upper;
  if (fore){
    const ref = rotRef(fore.rotation,'y'); const s = ref.get();
    tweenRot(ref, s, s+0.35, 110, ()=>{ dummyHit(-1); playSound('tan'); tweenRot(ref, s+0.35, s, 120, ()=>busy=false); });
  } else { dummyHit(-1); playSound('tan'); busy=false; }
}
function bon(){
  if (busy) return; busy = true;
  const upper = charBones.R.upper;
  if (upper){
    const ref = rotRef(upper.rotation,'x'); const s = ref.get();
    tweenRot(ref, s, s-0.6, 120, ()=>{ dummyHit(0); playSound('bon'); tweenRot(ref, s-0.6, s, 120, ()=>busy=false); });
  } else { dummyHit(0); playSound('bon'); busy=false; }
}
function punch(){
  if (busy) return; busy = true;
  const fore = charBones.L.fore || charBones.L.upper;
  if (fore){
    const ref = rotRef(fore.rotation,'y'); const s = ref.get();
    tweenRot(ref, s, s+0.55, 90, ()=>{ dummyHit(0); playSound('punch'); tweenRot(ref, s+0.55, s, 110, ()=>busy=false); });
  } else { dummyHit(0); playSound('punch'); busy=false; }
}

/* ===== resize + boucle ===== */
addEventListener('resize', ()=>{
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});
function animate(){ renderer.render(scene, camera); requestAnimationFrame(animate); }
requestAnimationFrame(animate);
</script>
</body>
</html>
